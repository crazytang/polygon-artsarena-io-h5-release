var b=Object.defineProperty;var x=(l,t,a)=>t in l?b(l,t,{enumerable:!0,configurable:!0,writable:!0,value:a}):l[t]=a;var T=(l,t,a)=>(x(l,typeof t!="symbol"?t+"":t,a),a);import{$ as E,a3 as C,al as F,am as _,a$ as B,aI as O,bt as d,aM as y,bu as p,a2 as I,bv as M}from"./index-1e3b5e9c.js";import{g as P,c as D,a as L}from"./match-utils-793d0e6d.js";import{E as V}from"./erc721-service-bd0ec81e.js";import{C as H,T as S}from"./transaction-api-service-8b388dbb.js";import{C as k}from"./contract-data-service-bee1e717.js";import{B as u}from"./battle-contract-service-bdced59b.js";import{f as A,M as v}from"./match-api-service-85ee51bf.js";import{C as R}from"./challenge-api-service-8347c7e6.js";import{C as G}from"./match-data-ext-5e1df082.js";import{B as $}from"./constants-2bfeaeae.js";class g extends H{constructor(t,a,e){super(t,a,e)}static async connect(){const t=E(),a=await k.getL1NFTBattlePoolData();return new g(a.contract_address,a.abi,t)}async nonce(){const t=await this.contract.nonce();return Number(t)}async getNFTOwner(t,a){const e=await this.contract.getNFTOwner(t,a);return String(e)}async isStakedNFT(t,a,e){return!!await this.contract.isStakedNFT(t,a,e)}async userNFTIsAvailable(t,a,e,r){return!!await this.contract.userNFTIsAvailable(t,a,e,r)}async stake(t,a){await this.checkNetwork();const{hash:e}=await C({...this.getConfig(),functionName:"stake",args:[t,a]});return await new S().pushTxHash(e,this.chainId),e}async redeem(t,a){await this.checkNetwork();const{hash:e}=await C({...this.getConfig(),functionName:"redeem",args:[t,a]});return await new S().pushTxHash(e,this.chainId),e}}class f extends F{constructor(){super();T(this,"account")}async createMatch(a){const e=this.gateway+"/match/v2/create",r=await _.post(e,a);return this.checkResponse(r),A(r.data.data)}async challengeMatch(a){const e=this.gateway+"/match/v2/challenge",r=await _.post(e,a);return this.checkResponse(r),new G(r.data.data)}async getStartMatchParam(a){const e=this.gateway+"/match/v2/get-start-param",r=await _.post(e,a);return this.checkResponse(r),A(r.data.data)}}class N{static async getPoolAddress(){return(await k.getL1NFTBattlePoolData()).contract_address}static async stake(t,a,e){if(t===null)throw new Error("chain_id is null");const r=B();if(!r.address)throw new Error("user_account is empty");const s=await N.getPoolAddress(),n=new V(a,t);let o="";await n.isApprovedForAll(r.address,s)||(o=await n.setApprovalForAll(s,!0),await n.waitForTransaction(o));const h=await g.connect();o=await h.stake(a,e),console.log("nft_battle_pool_service.stake() tx",o),await h.waitForTransaction(o),console.log("staked")}static async redeem(t,a,e,r){if(!a)throw new Error("nft_owner is empty");if(!O(t))throw new Error("chain_id is invalid");const s=await g.connect(),n=await s.redeem(e,r);console.log("nft_battle_pool_service.redeem() tx",n),await s.waitForTransaction(n),console.log("redeemed")}static async createMatch(t,a,e,r,s,n=!1){t=d(t),e=d(e);const o=new f,c={matchId:y,autoStart:n,matchListTime:p(),arenaCreatorNftAddress:e,arenaCreatorTokenId:r,arenaCreatorOwner:t,sellPrice:I(s,18).toString(),arenaCreatorSignature:y,chainId:a};if(c.matchId=P(c.matchListTime,c.arenaCreatorOwner,c.arenaCreatorNftAddress,c.arenaCreatorTokenId,a),await(await u.connect()).getMatchId(c.matchListTime,c.arenaCreatorOwner,c.arenaCreatorNftAddress,c.arenaCreatorTokenId)!==c.matchId)throw new Error("match_id is invalid");let w=D(c.matchId,c.autoStart,c.matchListTime,c.arenaCreatorOwner,c.arenaCreatorNftAddress,c.arenaCreatorTokenId,c.sellPrice);return c.arenaCreatorSignature=await M(w),await o.createMatch(c)}static async challengeMatch(t,a,e,r,s,n,o=!1){if(!t)throw new Error("match_id is empty");if(!a)throw new Error("challenger_address is empty");if(!n||parseFloat(n.toString())<=0)throw new Error("sell_price is invalid");a=d(a),r=d(r);const h=await new v().getMatchDataByMatchId(e,t);if(!h)throw new Error("match data is not existed");const i={matchId:t,challengerNftAddress:r,challengerTokenId:s,challengerOwner:a,sellPrice:I(n,18).toString(),challengeOwnerSignature:""},w=L(i.matchId,i.challengerOwner,i.challengerNftAddress,i.challengerTokenId,i.sellPrice,h.arenaCreatorSignature);i.challengeOwnerSignature=await M(w);try{return await new f().challengeMatch(i)}catch(m){if(o&&m.message.includes("challenge is exists"))return null;throw m}}static async startMatch(t,a,e){const r=new v,s=new f;if(!await r.getMatchDataByMatchId(t,e))throw new Error("match data is not existed");if(!await new R().getChallengeDataById(a))throw new Error("challenge data is not existed");const h={challengeId:a,matchStartTime:p(),matchEndTime:p()+$,matchId:e,arenaOwnerSignature:""},i=await s.getStartMatchParam(h),w=await u.connect(),m=await w.startMatchV2(i);return console.log("battle_contract_service.startMatch() tx",m),await w.waitForTransaction(m),console.log("started"),m}static async determine(t){const e=await new v().getMatchResult(t);console.log("match_result_param2",e);const r=await u.connect(),s=await r.determine(e);console.log("battle_contract_service.determine() tx",s);try{const n=await r.waitForTransaction(s)}catch(n){if(n.message.includes("Cannot convert null to a BigInt"))console.error("determine waitForTransaction error:",n.message);else throw new Error("nonce is invalid")}return console.log("determined"),s}}export{N as M,g as N};
