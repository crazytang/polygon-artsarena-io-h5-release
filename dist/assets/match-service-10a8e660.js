import{s as d,k as E,i as x,w as A,h as L,a as O,A as P,e as f,j as H,H as I,l as R,n as k,m as _,o as S}from"./axios-c59a5c3f.js";import{a as B,E as q,C as j}from"./user-service-6e9a877a.js";import{C as N}from"./contract-data-service-b5ce41dd.js";import{M as T}from"./match-api-service-4ab8a5c7.js";import{C as M}from"./challenge-data-66d06939.js";const K=(h,t,a,e,r,n,o)=>d(["bytes32","bytes32","uint256","address","address","uint256","uint256"],[h,t,a,e,r,n,o]),Z=(h,t,a,e,r,n,o,s,c)=>{const i=[h,t],l=["bytes32","bytes32"],w=[e,r,a],g=["address","uint256","address"],m=[o,s,n,c],p=["address","uint256","address","uint256"],y=d(l,i),C=d(g,w),v=d(p,m);return E(x([y,C,v]))},z=(h,t,a,e,r,n,o,s,c,i)=>{const l=[h,t,a,e],w=["bytes32","bytes32","uint256","uint256"],g=[n,o,r],m=["address","uint256","address"],p=[c,i,s],y=["address","uint256","address"],C=d(w,l),v=d(m,g),D=d(y,p);return E(x([C,v,D]))},G=(h,t,a,e,r)=>{if(!h)throw new Error("matchListTime is required");if(!t)throw new Error("arenaCreator.owner is required");if(!a)throw new Error("arenaCreator.nftAddress is required");return d(["uint256","address","address","uint256","uint256"],[h,t,a,e,r])};class u extends B{constructor(t,a,e){super(t,a,e)}static async connect(){const t=L(),a=await N.getL1NFTBattlePoolData();return new u(a.contract_address,a.abi,t)}async nonce(){const t=await this.contract.nonce();return Number(t)}async getNFTOwner(t,a){const e=await this.contract.getNFTOwner(t,a);return String(e)}async isStakedNFT(t,a,e){return!!await this.contract.isStakedNFT(t,a,e)}async userNFTIsAvailable(t,a,e,r){return!!await this.contract.userNFTIsAvailable(t,a,e,r)}async stake(t,a){const{hash:e}=await A({...this.getConfig(),functionName:"stake",args:[t,a]});return e}async redeem(t,a,e){const{hash:r}=await A({...this.getConfig(),functionName:"redeem",args:[t,a,e]});return r}}class b extends B{constructor(t,a,e){super(t,a,e)}static async connect(){const t=O(),a=await N.getL2BattleData(t);return new b(a.contract_address,a.abi,t)}async startMatch(t){const{hash:a}=await A({...this.getConfig(),functionName:"startMatch",args:[t]});return a}}class J extends P{async getChallengeDataById(t){const a=this.gateway+"/challenge/id/"+t,e=await f.get(a);return this.checkResponse(e),new M(e.data.data)}async getChallengeDataListByMatchId(t){const a=this.gateway+"/challenge/match/"+t,e=await f.get(a);return this.checkResponse(e),e.data.data.map(r=>new M(r))}async getChallengeDataByMatchIdAndNftAddressAndTokenId(t,a,e){const r=this.gateway+"/challenge/match/"+t+"/"+a+"/"+e,n=await f.get(r);return this.checkResponse(n),new M(n.data.data)}}class F{static async getPoolAddress(){return(await N.getL1NFTBattlePoolData()).contract_address}static async stake(t,a,e){if(t===null)throw new Error("chain_id is null");const r=await F.getPoolAddress(),n=new q(a,t),o=await n.getApproved(e);let s="";o!=r&&(s=await n.approve(r,e),console.log("erc721_service.approve() tx",s),await n.waitForTransaction(s));const c=await u.connect();s=await c.stake(a,e),console.log("nft_battle_pool_service.stake() tx",s),await c.waitForTransaction(s),console.log("staked")}static async redeem(t,a,e,r){if(!a)throw new Error("nft_owner is empty");if(!H(t))throw new Error("chain_id is invalid");const n=await u.connect(),o=await n.nonce();if(console.log("nonce",o),o===null)throw new Error("nonce is empty");const c=await new j().getRedeemNFTSignature(a,e,r,o),i=await n.redeem(e,r,c);console.log("nft_battle_pool_service.redeem() tx",i),await n.waitForTransaction(i),console.log("redeemed")}static async createMatch(t,a,e,r,n){const o=new T,s={matchId:I,matchListTime:R(),teamMatchId:I,arenaCreatorNftAddress:e,arenaCreatorTokenId:r,arenaCreatorOwner:t,sellPrice:k(n,18).toString(),arenaCreatorSignature:I,chainId:a};s.matchId=G(s.matchListTime,s.arenaCreatorOwner,s.arenaCreatorNftAddress,s.arenaCreatorTokenId,a);let c=K(s.matchId,s.teamMatchId,s.matchListTime,s.arenaCreatorOwner,s.arenaCreatorNftAddress,s.arenaCreatorTokenId,s.sellPrice);return s.arenaCreatorSignature=await _(c),await o.createMatch(s)}static async challengeMatch(t,a,e,r,n,o){if(!t)throw new Error("match_id is empty");if(!a)throw new Error("challenger_address is empty");if(!o||parseFloat(o.toString())<=0)throw new Error("sell_price is invalid");const s=new T,c=await s.getMatchDataByMatchId(e,t);if(!c)throw new Error("match data is not existed");const i={matchId:t,challengerNftAddress:r,challengerTokenId:n,challengerOwner:a,sellPrice:k(o,18).toString(),challengeOwnerSignature:""},l=Z(i.matchId,c.teamMatchId,c.arenaCreatorAddress,c.arenaCreatorNftAddress,c.arenaCreatorTokenId,i.challengerOwner,i.challengerNftAddress,i.challengerTokenId,i.sellPrice);return i.challengeOwnerSignature=await _(l),await s.challengeMatch(i)}static async startMatch(t,a,e){const r=new T,n=await r.getMatchDataByMatchId(t,e);if(!n)throw new Error("match data is not existed");const s=await new J().getChallengeDataById(a);if(!s)throw new Error("challenge data is not existed");const c={challengeId:a,matchId:e,arenaOwnerSignature:""},i=z(e,n.teamMatchId,S(n.matchStartTime),S(n.matchEndTime),n.arenaCreatorAddress,n.arenaCreatorNftAddress,n.arenaCreatorTokenId,s.challengerAddress,s.challengerNftAddress,s.challengerTokenId);c.arenaOwnerSignature=await _(i);const l=await r.startMatch(c),w=await b.connect(),g=await w.startMatch(l);console.log("battle_contract_service.startMatch() tx",g),await w.waitForTransaction(g),console.log("started")}}export{F as M};
